Le fichier Helloworld du challenge contient des donné crypté et un poeme qui est inverser. En utilisant un code python on peut de déinverser. La lecture du poeme indique que les donné crypter contienne des clé de chiffrement telque modulus, exposant et un générateur ce qui nous rappelle les paramètre d'un comunaction Diffle-Helfman.
Ainsi nous devons inverser les données et les decoder en base64 puis en hexadécimal pour avoir les paramèetre .
A la fin, le ciphertext est obtenue.

voici les parametre qui sont pour le cryptage RSA :

c=30091609888541740020558685497804908419626737470520032527719483228879252577039801015510709487138953199350146234850927516280480992859732105270372513235135168827381858347802
e=65537
c2=20036831866969991266754126104311968399439556554966441012761708515247306641845687741095426327122920434262137818476447897347733317949839916263165357216430648037952990146626
n=71641831546926719303369645296528546480083425905458247405279061196214424558100678947996271179659761521775290973790597533683668081173314940392098256721488468660504161994357

Puisque nous avons pas la clé privé et que le modulus est petit nous allons le cachr et le decode avec le code suivant : 

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
from Crypto.Util.number import *
from factordb.factordb import FactorDB

c1=?
e=65537
c2=?
n=?


f = FactorDB(n)
f.connect()
r = f.get_factor_list()

p = int(r[0])
q = int(r[1])
phi = (p-1)*(q-1)
d = inverse(e, phi)
cipher1 = long_to_bytes(pow(c1, d, n))
cipher2 = long_to_bytes(pow(c2, d, n))

print("cipher1 : ", cipher1)
print("cipher2 : ", cipher2)


flag : Exploit3rs{und3r_th3_s01l}

===================================================